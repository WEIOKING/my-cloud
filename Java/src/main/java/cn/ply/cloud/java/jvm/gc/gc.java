package cn.ply.cloud.java.jvm.gc;

/**
 * @Author ply
 * @Description 垃圾回收
 * @Date created in 2021/4/8
 * @ModifiedBy
 */
public class gc {
    /**
     * 运行时数据区域
     * 1、程序计数器：
     *      当前线程执行的字节码的行号指示器，分支、循环、跳转、异常处理、线程恢复等基础功能依赖程序计数器实现
     * 2、Java虚拟机栈
     *      线程私有，生命周期与线程相同；用于存储局部变量表、操作数栈、动态链接、方法出口等信息；
     *      局部变量表存放了编译期可知的各种基本类型、对象引用和returnAddress类型
     * 3、本地方法栈
     *      与虚拟机栈功能相似，本地方法栈为虚拟机使用到的Native方法服务
     * 4、Java堆
     *      所有的对象实例和数组都在堆上分配。Java堆可细分为新生代和老年代；
     * 5、方法区
     *      用于存储被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据
     * 6、运行时常量池
     *      方法区的一部分。用于存放编译器生成的各种字面量和符号引用。
     * 7、直接内存
     *      并不是虚拟机运行时数据区的一部分；JDK1.4 新加入的NIO 引入一种基于通道的缓冲区的I/O 方式，它可以使用Native函数库直接分配堆外内存。
     */
    /**
     * 如何判断对象已经死了
     * 1、引用计数法； 缺陷：很难解决对象之间的循环引用
     * 2、可达性分析算法； 通过一系列“GC ROOTS”对象做为起点，向下搜索所走过的路径称为引用链，当一个对象没有任何引用链相连时，则证明此对象是不可用的。
     */
    /**
     * 垃圾收集算法
     * 1、标记 - 清除算法；缺陷：清除后产生大量碎片内存，导致没有连续内存支撑大对象分配
     * 2、复制算法；缺陷；内存缩小为原来一半
     * 3、标记 - 整理算法；
     * 4、分代收集算法；将Java堆分为新生代和老年代，不同年代采用不同的适当的收集算法
     */
    /**
     * 垃圾收集器
     * Serial 收集器
     * ParNew 收集器
     * Parallel Scavenge 收集器
     * Serial Old 收集器
     * Parallel Old 收集器
     * CMS 收集器
     * G1 收集器
     */
}
